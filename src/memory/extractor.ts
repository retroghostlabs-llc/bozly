/**
 * Session Memory Extractor
 *
 * Auto-extracts structured memory from session data.
 * Implements three extraction patterns:
 * 1. Token threshold (5,000 tokens) - First extraction
 * 2. Time threshold (1 hour) - Mid-session update
 * 3. Session completion - Final extraction
 *
 * @module memory/extractor
 */

import { SessionMemory, MemoryMetadata, ExtractionTrigger, Session } from "../core/types.js";
import { logger } from "../core/logger.js";

/**
 * Input data for memory extraction
 */
export interface ExtractionInput {
  session: Session;
  vaultContext?: string; // .bozly/context.md content
  commandContent?: string; // .bozly/commands/{command}.md content
  executionOutput?: string; // AI response output
  filesChanged?: string[]; // List of files that were modified
  tokensUsed?: number; // Token count estimate
  toolCallsCount?: number; // Number of tool calls made
  executionTimeMs?: number; // Execution duration
}

/**
 * Vault-specific memory template patterns
 */
interface MemoryTemplate {
  currentState: (input: ExtractionInput) => string;
  taskSpec: (input: ExtractionInput) => string;
  workflow: (input: ExtractionInput) => string;
  errors: (input: ExtractionInput) => string;
  learnings: (input: ExtractionInput) => string;
  keyResults: (input: ExtractionInput) => string;
}

/**
 * Vault type detection
 */
function detectVaultType(vaultName: string, context?: string): string {
  const lowerName = vaultName.toLowerCase();
  const lowerContext = (context || "").toLowerCase();

  if (
    lowerName.includes("music") ||
    lowerContext.includes("music") ||
    lowerContext.includes("song") ||
    lowerContext.includes("rating")
  ) {
    return "music";
  }

  if (
    lowerName.includes("project") ||
    lowerContext.includes("sprint") ||
    lowerContext.includes("task")
  ) {
    return "project";
  }

  if (
    lowerName.includes("journal") ||
    lowerContext.includes("journal") ||
    lowerContext.includes("mood") ||
    lowerContext.includes("reflection")
  ) {
    return "journal";
  }

  return "generic";
}

/**
 * Get vault-specific memory template
 */
function getMemoryTemplate(vaultType: string): MemoryTemplate {
  const templates: Record<string, MemoryTemplate> = {
    music: {
      currentState: (input) =>
        `Analyzing and rating songs in the music vault. Latest session: ${input.session.command} executed.`,
      taskSpec: (input) =>
        `Rate and organize music using the vault's scoring system. Command: ${input.session.command}`,
      workflow: (input) =>
        `Used command: ${input.session.command}\n- Provider: ${input.session.provider}\n- Execution time: ${input.executionTimeMs}ms`,
      errors: (input) =>
        input.session.error
          ? `Error encountered: ${input.session.error.message}`
          : "No errors in execution",
      learnings: () => `Session provided insights for music rating patterns and consistency.`,
      keyResults: (input) =>
        `Command executed successfully. Output generated by ${input.session.provider}.`,
    },
    project: {
      currentState: () =>
        `Working on project planning and execution. Current command: project planning`,
      taskSpec: () => `Manage project sprints and tasks`,
      workflow: (input) =>
        `Sprint planning workflow: ${input.session.command}\n- Provider: ${input.session.provider}\n- Duration: ${input.executionTimeMs}ms`,
      errors: (input) =>
        input.session.error ? `Issue: ${input.session.error.message}` : "No errors in session",
      learnings: () => `Project session provided insights on sprint planning and task estimation.`,
      keyResults: (input) =>
        `Sprint plan or task analysis generated via ${input.session.provider}.`,
    },
    journal: {
      currentState: () => `Recording journal entries and mood reflections`,
      taskSpec: () => `Daily journaling and mood tracking`,
      workflow: (input) =>
        `Journal workflow: ${input.session.command}\n- Provider: ${input.session.provider}\n- Time: ${input.executionTimeMs}ms`,
      errors: (input) =>
        input.session.error
          ? `Session issue: ${input.session.error.message}`
          : "Session completed successfully",
      learnings: () => `Mood and reflection patterns documented from this session.`,
      keyResults: (input) =>
        `Journal entry or mood analysis created via ${input.session.provider}.`,
    },
    generic: {
      currentState: (input) =>
        `Executed command: ${input.session.command} on ${input.session.nodeName}`,
      taskSpec: (input) => `Command execution: ${input.session.command}`,
      workflow: (input) =>
        `Command: ${input.session.command}\n- Provider: ${input.session.provider}\n- Duration: ${input.executionTimeMs}ms`,
      errors: (input) =>
        input.session.error ? `Error: ${input.session.error.message}` : "No errors",
      learnings: () => `Session completed successfully with insights generated.`,
      keyResults: (input) => `Output generated via ${input.session.provider}.`,
    },
  };

  return templates[vaultType] || templates.generic;
}

/**
 * Generate tags for memory indexing
 */
function generateTags(input: ExtractionInput, vaultType: string): string[] {
  const tags = [
    vaultType,
    input.session.command.replace(/^bozly run /, ""),
    input.session.provider,
    input.session.status,
  ];

  // Add vault name as tag
  if (input.session.nodeName) {
    tags.push(input.session.nodeName.toLowerCase().replace(/\s+/g, "-"));
  }

  // Add execution time-based tag
  if (input.executionTimeMs) {
    if (input.executionTimeMs < 5000) {
      tags.push("quick");
    } else if (input.executionTimeMs < 30000) {
      tags.push("normal");
    } else {
      tags.push("long-running");
    }
  }

  return [...new Set(tags)]; // Remove duplicates
}

/**
 * Calculate estimated token count
 */
function estimateTokens(input: ExtractionInput): number {
  let tokens = input.tokensUsed ?? 0;

  if (!tokens) {
    // Rough estimate: ~1 token per 4 characters
    let totalChars = 0;
    if (input.vaultContext) {
      totalChars += input.vaultContext.length;
    }
    if (input.commandContent) {
      totalChars += input.commandContent.length;
    }
    if (input.executionOutput) {
      totalChars += input.executionOutput.length;
    }
    tokens = Math.ceil(totalChars / 4);
  }

  return tokens;
}

/**
 * Calculate duration in minutes
 */
function calculateDurationMinutes(executionTimeMs?: number): number {
  return Math.round((executionTimeMs ?? 0) / 60000);
}

/**
 * Memory Extractor - Auto-extracts structured memory from sessions
 */
export class MemoryExtractor {
  /**
   * Auto-extract session memory based on trigger
   */
  static extract(input: ExtractionInput, _trigger: ExtractionTrigger): SessionMemory {
    const vaultType = detectVaultType(input.session.nodeName, input.vaultContext);
    const template = getMemoryTemplate(vaultType);

    // Generate summary
    const summary = `${input.session.command} executed on ${input.session.nodeName}`;

    // Create memory object
    const memory: SessionMemory = {
      sessionId: input.session.id,
      nodeId: input.session.nodeId,
      nodeName: input.session.nodeName,
      timestamp: input.session.timestamp,
      durationMinutes: calculateDurationMinutes(input.executionTimeMs),
      tokenCount: estimateTokens(input),
      aiProvider: input.session.provider,
      command: input.session.command,
      title: `${input.session.command} - ${summary}`,
      currentState: template.currentState(input),
      taskSpec: template.taskSpec(input),
      workflow: template.workflow(input),
      errors: template.errors(input),
      learnings: template.learnings(input),
      keyResults: template.keyResults(input),
      tags: generateTags(input, vaultType),
      summary,
    };

    logger.debug(`Extracted memory for session ${input.session.id} (${vaultType})`);
    return memory;
  }

  /**
   * Generate metadata for memory
   */
  static generateMetadata(
    memory: SessionMemory,
    trigger: ExtractionTrigger,
    vaultType: string
  ): MemoryMetadata {
    return {
      sessionId: memory.sessionId,
      nodeId: memory.nodeId,
      nodeName: memory.nodeName,
      timestamp: memory.timestamp,
      durationMinutes: memory.durationMinutes,
      tokenCount: memory.tokenCount,
      aiProvider: memory.aiProvider,
      command: memory.command,
      memoryAutoExtracted: true,
      extractionTrigger: trigger,
      tags: memory.tags,
      relevantPreviousSessions: memory.relevantSessions || [],
      summary: memory.summary,
      vaultType,
    };
  }

  /**
   * Convert SessionMemory to markdown format
   */
  static toMarkdown(memory: SessionMemory, metadata: MemoryMetadata): string {
    return `# Session: ${memory.nodeName} â€” ${memory.title}

## Current State
${memory.currentState || "No state information"}

## Task Specification
${memory.taskSpec || "No task specification"}

## Workflow
${memory.workflow || "No workflow information"}

## Errors & Corrections
${memory.errors || "No errors encountered"}

## Learnings
${memory.learnings || "No learnings recorded"}

## Key Results
${memory.keyResults || "No results recorded"}

## Metadata
- Session ID: ${metadata.sessionId}
- Timestamp: ${metadata.timestamp}
- Duration: ${metadata.durationMinutes} minutes
- Token Count: ${metadata.tokenCount}
- AI Provider: ${metadata.aiProvider}
- Command: ${metadata.command}
- Vault Type: ${metadata.vaultType}
- Tags: ${metadata.tags.join(", ")}
- Extraction Trigger: ${metadata.extractionTrigger}

---
*Memory auto-extracted by BOZLY from session context*
`;
  }
}
